<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NSFW Image Classifier</title>
  <style>
    #result {
      margin-top: 20px;
    }
    #uploadedImage {
      max-width: 100%;
      height: auto;
      margin-top: 20px;
      transition: filter 0.3s;
    }
    #videoContainer {
      position: relative;
      width: 100%;
      height: auto;
      margin-top: 20px;
    }
    #webcamFeed {
      width: 100%;
      height: auto;
    }
    #videoCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: auto;
      pointer-events: none; /* Allow interaction with video below */
      transition: filter 0.3s; /* Smooth transition for blur effect */
    }
    .blurred {
      filter: blur(30px);
    }
  </style>
</head>
<body>
  <h1>NSFW Image Classifier</h1>

  <!-- Form for uploading images -->
  <form id="uploadForm" enctype="multipart/form-data">
    <label for="imageUpload">Choose an image to upload:</label>
    <input type="file" id="imageUpload" name="image" accept="image/*" required>
    <button type="submit">Upload Image</button>
  </form>

  <!-- Result and uploaded image display -->
  <div id="result"></div>
  <img id="uploadedImage" style="display: none;">

  <!-- Webcam section -->
  <h2>Webcam Feed</h2>
  <div id="videoContainer">
    <video id="webcamFeed" autoplay></video>
    <canvas id="videoCanvas"></canvas>
  </div>
  <button id="startVideo">Start Video</button>
  <button id="stopVideo">Stop Video</button>

  <script>
    const videoElement = document.getElementById('webcamFeed');
    const canvasElement = document.getElementById('videoCanvas');
    const ctx = canvasElement.getContext('2d');
    const startButton = document.getElementById('startVideo');
    const stopButton = document.getElementById('stopVideo');
    const resultElement = document.getElementById('result');

    let isVideoOn = false;
    let isSafe = true;
    let intervalId = null;

    async function startVideo() {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      videoElement.srcObject = stream;
      videoElement.onloadedmetadata = () => {
        videoElement.play();
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        isVideoOn = true;
        startFrameAnalysis();
      };
    }

    function stopVideo() {
      const stream = videoElement.srcObject;
      if (stream) {
        const tracks = stream.getTracks();
        tracks.forEach(track => track.stop());
        videoElement.srcObject = null;
      }
      isVideoOn = false;
      clearInterval(intervalId);
      canvasElement.classList.remove('blurred'); // Ensure blur is removed when video stops
    }

    function startFrameAnalysis() {
      intervalId = setInterval(async () => {
        if (!isVideoOn) return;

        ctx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

        canvasElement.toBlob(async (blob) => {
          const formData = new FormData();
          formData.append('image', blob, 'frame.jpg');

          try {
            const response = await fetch('http://localhost:5552/nsfw', {
              method: 'POST',
              body: formData
            });

            if (!response.ok) {
              throw new Error('Network response was not ok');
            }

            const result = await response.json();
            console.log(result); // For debugging
            updateBlurState(result);
          } catch (error) {
            resultElement.innerText = `Error: ${error.message}`;
          }
        }, 'image/jpeg');
      }, 1000); // Capture frame every 1000 milliseconds (1 second)
    }

    function updateBlurState(result) {
      let neutralProbability = 0;
      let hentaiProbability = 0;
      let pornProbability = 0;
      let sexyProbability = 0;

      for (const prediction of result) {
        switch (prediction.className) {
          case 'Neutral':
            neutralProbability = prediction.probability;
            break;
          case 'Hentai':
            hentaiProbability = prediction.probability;
            break;
          case 'Porn':
            pornProbability = prediction.probability;
            break;
          case 'Sexy':
            sexyProbability = prediction.probability;
            break;
        }
      }

      isSafe = neutralProbability > 0.5 &&
               hentaiProbability <= 0.5 &&
               pornProbability <= 0.5 &&
               sexyProbability <= 0.5;

      if (!isSafe) {
        canvasElement.classList.add('blurred');
      } else {
        canvasElement.classList.remove('blurred');
      }
    }

    startButton.addEventListener('click', startVideo);
    stopButton.addEventListener('click', stopVideo);

    document.getElementById('uploadForm').addEventListener('submit', async function(event) {
      event.preventDefault();

      const formData = new FormData();
      formData.append('image', document.getElementById('imageUpload').files[0]);

      try {
        const response = await fetch('http://localhost:5552/nsfw', {
          method: 'POST',
          body: formData
        });

        if (!response.ok) {
          throw new Error('Network response was not ok');
        }

        const result = await response.json();
        console.log(result); // For debugging
        displayResult(result);
      } catch (error) {
        resultElement.innerText = `Error: ${error.message}`;
      }
    });

    function displayResult(result) {
      let isSafe = true;
      let neutralProbability = 0;
      let hentaiProbability = 0;
      let pornProbability = 0;
      let sexyProbability = 0;

      let resultHTML = '<h2>NSFW Classification Results:</h2><ul>';

      for (const prediction of result) {
        resultHTML += `<li>${prediction.className}: ${prediction.probability.toFixed(3)}</li>`;

        switch (prediction.className) {
          case 'Neutral':
            neutralProbability = prediction.probability;
            break;
          case 'Hentai':
            hentaiProbability = prediction.probability;
            break;
          case 'Porn':
            pornProbability = prediction.probability;
            break;
          case 'Sexy':
            sexyProbability = prediction.probability;
            break;
        }
      }
      resultHTML += '</ul>';

      if (neutralProbability > 0.5 &&
          hentaiProbability <= 0.5 &&
          pornProbability <= 0.5 &&
          sexyProbability <= 0.5) {
        isSafe = true;
      } else {
        isSafe = false;
      }

      if (isSafe) {
        resultElement.innerHTML = resultHTML + '<p>Safe Image</p>';
      } else {
        resultElement.innerHTML = resultHTML + '<p>Unsafe Image</p>';
      }
    }
  </script>
</body>
</html>
